{"Name":"Rivets","Id":1294,"Alias":"rivets","Description":"Rivets is a C# implementation of [App Links](http://applinks.org). It\u0027s functionally a port of Bolts, the Java/Obj-C implementation. Rivets is still in alpha and will be available on NuGet as a PCL when it is ready for its first release!\n\n## What are App Links?\n\nApp Links are a new open source, cross-platform standard for helping link between Mobile and the Web (and vice-versa). \n\nApp Links are a defined set of metadata that can be advertised within html of web pages that specify how to deep link to content inside of a Mobile app.  App Links are about the ***discovery*** of ways to *link between Mobile and Web*.\n\n - ***Mobile Deep Linking from the Web*** - Web pages can advertise special \u003cmetadata ... /\u003e tags within a normal web page, which specify how to deep link to content inside of a particular Mobile app.\n - ***Mobile to Mobile Linking*** - Mobile apps can resolve meta data from Web links into links for other mobile apps.\nHow does it work?\n\nLet\u0027s say you have a link: `http://example.com/products/widget` which displays information about a Widget you can buy on the web.\n\nWhat if you also had a native Mobile app which could display this information? How would you describe how to send users to it? Most platforms have some means of \u0027deep-linking\u0027 inside of an app, but each platform does it a little bit differently.\n\nUsing App Links, you can resolve what different mobile platform links are available for a given url. For example, if you resolve the app links for the url mentioned above, you could find that the equivalent deep link url for the iOS app is actually: `example://products?id=widget` (as is specified by the \u003cmetadata ... /\u003e tags right within the web page\u0027s html).\n\n\n## Learn More\nLearn more about App Links by visiting http://applinks.org","Version":"1.0.5.1","Summary":"Rivets is a C# implementation of App Links. It\u0027s functionally a port of Bolts, the Java/Obj-C implementation.","QuickStart":"# Getting Started with Rivets\nIt\u0027s important to understand what App Links actually are first.  You can visit the [App Links](http://applinks.org) as well as read the [official documentation](http://applinks.org/documentation/).  There\u0027s also a good [blog post](http://redth.info/what-are-app-links) helping explain App Links.\n\n## Replacing your Navigation with App Link Navigation\nOne of the most important parts of making App Link adoption a success is to make your own apps use App Link navigation in place of traditional web URL navigation.  \n\nYou should replace any navigation calls like this:\n\n```\n// iOS\nUIApplication.SharedApplication.OpenUrl(\"http://example.com/product/1\");\n\n// Android\nStartActivity(new Intent(Intent.ActionView, Uri.Parse(\"http://example.com/product/1\"));\n\n// Windows Phone\nWindows.System.Launcher.LaunchUriAsync(new Uri(\"http://example.com/product/1\"));\n```\nWith App Link navigation using Rivets like this:\n\n```\nvar result = await Rivets.AppLinks.Navigator.Navigate(\"http://example.com/product/1\");\n``` \n\nEvery URL you navigate to using Rivets will first be checked for App Link metadata, and an attempt to Navigate to a native app will be made.  If this is not possible, an attempt to navigate to a fallback web URL will be made.  Finally, if that also fails, the `NavigationResult` returned by `Navigate(..)` will be `Failed` and you can handle the situation how you see fit (eg: you may want to still navigate to the original web URL).\n\n## Handling Incoming App Link Navigation\n\nIf you want other apps to be able to App Link to your native apps there are a few steps to follow.\n\n\n#### Add App Link MetaData to your Web Pages\n\nFirst of all, your web page content should include the special `\u003cmetadata .. /\u003e` tags defining what different platforms you have apps on, and what the deep link to those apps are for the given web page\u0027s content.\n\nYou can read more about this in the [official documentation](http://applinks.org/documentation/), but here is an example of what you might add to your web page:\n\n```html\n\u003chead\u003e\n \u003c!-- iOS --\u003e\n \u003cmeta property=\"al:ios:url\" content=\"example://products?id=1\" /\u003e\n \u003cmeta property=\"al:ios:app_store_id\" content=\"12345\" /\u003e\n \u003cmeta property=\"al:ios:app_name\" content=\"Example App\" /\u003e\n \n \u003c!-- Android --\u003e\n \u003cmeta property=\"al:android:url\" content=\"example://products?id=1\" /\u003e\n \u003cmeta property=\"al:android:package\" content=\"com.example.app\" /\u003e\n \u003cmeta property=\"al:android:app_name\" content=\"Example App\" /\u003e\n \n \u003c!-- Windows Phone --\u003e\n \u003cmeta property=\"al:windows_phone:url\" content=\"example://products?id=1\" /\u003e\n \u003cmeta property=\"al:windows_phone:app_id\" content=\"abcde-guid-12345\" /\u003e\n \u003cmeta property=\"al:windows_phone:app_name\" content=\"Example App\" /\u003e\n  \n \u003c!-- Web Fallback --\u003e\n \u003cmeta property=\"al:web:url\" content=\"http://example.com/product/1\" /\u003e\n\u003c/head\u003e\n```\n\n\n#### Registering your App for handling URL\u0027s\n\nMost platforms have a concept of being able to receive incoming information from other apps.  iOS and Windows Phone platforms require that you register your app to handle a specific URL scheme.  Android is a bit different in that you can describe what types of Intents your various activities can be selected to handle.  This is nothing specific to Rivets or App Links.\n\nTo register your app to handle a URL scheme on iOS, you would need to add the following to your `Info.plist` file:\n\n\n\nTo register your app to handle a URL scheme on Windows phone, you would add the following to your `WPManifest.xml` file (after the closing Tokens tag, and before the opening ScreenResolutions tag):\n\n```xml\n\u003c/Tokens\u003e\n\u003cExtensions\u003e\n  \u003cProtocol Name=\"example\" NavUriFragment=\"encodedLaunchUri=%s\" TaskID=\"_default\" /\u003e\n\u003c/Extensions\u003e\n\u003cScreenResolutions\u003e\n```\n\nOn Android, you need to mark up your Intent with a Filter for your URL scheme.  You could do this by editing the `AndroidManifest.xml` file, or you can add some attributes to your activity like this:\n\n```\n[Activity (Label = \"Product Details\")]\t\t\t\n[IntentFilter(new [] {Android.Content.Intent.ActionView }, \n\tDataScheme=\"example\", \n\tDataHost=\"*\", \n\tCategories=new [] { Android.Content.Intent.CategoryDefault })]\npublic class ProductActivity : Activity\n{\n\t// ...\n}\n```\n\n\n#### Parsing Incoming App Link data\n\nThere\u0027s a special class called `AppLinkUrl` to help you parse the data you receive from incoming App Links.\n\nOn iOS in your AppDelegate, OpenUrl should be overridden to handle incoming links.  You can construct and use an `AppLinkUrl` instance something like this:\n\n```csharp\npublic override bool OpenUrl (UIApplication app, NSUrl url, string srcApp, NSObject annotation)\n{\n\tvar rurl = new Rivets.AppLinkUrl (url.ToString ());\n\n\tif (rurl.InputUrl.Host.Equals (\"products\")) {\n\t\tvar id = rurl.InputQueryParameters [\"id\"];\n\n\t\tvar c = new ProductViewController (id, rurl.Referrer);\n\t\tnavController.PushViewController (c, true);\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\n```\n\nOn Android since your Activity registers the Intent filter, it will be directly opened for you.  You will still need to parse the `al_applink_data` intent which contains the App Link metadata used to launch the app:\n\n```\nprotected override void OnCreate (Bundle bundle)\n{\n\tbase.OnCreate (bundle);\n\n\tSetContentView (Resource.Layout.ProductLayout);\n\n\tvar id = string.Empty;\n\n\t// See if the activity was opened from an internal Intent\n\t// which could have the product id in the Extras\n\tif (Intent.HasExtra (\"PRODUCT_ID\")) {\n\t\tid = Intent.GetStringExtra (\"PRODUCT_ID\");\n\t} else {\n\n\t\tvar appLinkData = Intent.GetStringExtra (\"al_applink_data\");\n\n\t\t// Otherwise, check and see if we were launched from an AppLink\n\t\t// and if so, Parse the url from the Intent Data\n\t\tvar alUrl = new Rivets.AppLinkUrl (Intent.Data.ToString (), appLinkData);\n\n\t\t// TargetQueryParameters will contain our product id\n\t\tif (alUrl != null \u0026\u0026 alUrl.InputQueryParameters.ContainsKey (\"id\")) {\n\t\t\tid = alUrl.TargetQueryParameters [\"id\"];\n\t\t}\n\t}\n}\n```\n\nOn Windows Phone you need to subclass UriMapper:\n\n```\nclass MyAppLinkUriMapper : UriMapperBase\n{\n    const string EXT_LAUNCH_URI = \"/Protocol?encodedLaunchUri=\";\n\n    public override Uri MapUri(Uri uri)\n    {\n        var url = uri.ToString();\n\n        if (!url.StartsWith(EXT_LAUNCH_URI))\n            return uri;\n\n        // Get the encodedLaunchUri Query parameter \n        // which is actually the url we are interested in\n        var launchUrl = HttpUtility.UrlDecode(url.Substring(url.IndexOf(EXT_LAUNCH_URI) + EXT_LAUNCH_URI.Length));\n        \n        // Build the AppLinkUrl from this url passed in\n        var apUrl = new Rivets.AppLinkUrl(launchUrl);\n\n        // See if the url fits some deep linking rules for our app\n        if (apUrl.InputUrl.Scheme.StartsWith(\"example\") \u0026\u0026 apUrl.InputUrl.Host.Contains(\"product\"))\n        {\n            // Get the id parameter\n            var id = string.Empty;\n            if (apUrl.InputQueryParameters.ContainsKey(\"id\"))\n                id = apUrl.InputQueryParameters[\"id\"];\n\n            // Finally, navigate to the product page (deep link)\n            return new Uri(\"/Product.xaml?id=\" + id, UriKind.Relative);\n        }\n\n        return uri;                        \n    }\n}\n```\n\nNOTE: You\u0027ll need to set your `RootFrame.UriMapper = new MyAppLinkUriMapper();` in your App\u0027s initialization.\n\n\n## Using Facebook\u0027s Index to Resolve AppLinks\nTo help with the adoption and lower the overhead required to parse AppLinks, Facebook has created their own public index.  Instead of you fetching the HTML content of a page and parsing the AppLink metadata yourself (on a mobile device), you can query the Facebook Index instead. \n\nWhen you send a request to the Facebook Index, it will first check its cache to see if it has been asked about this content before, and if so, it will quickly returned cached results to you.  If it has nothing in its cache, it will go out and parse the HTML for you and return any results it finds.\n\nThere are a couple advantages to using Facebook Index to resolve AppLinks:\n\n1. Speed: Cached results are returned VERY quickly, and even if there are no cached results, Facebook has much better peering to data centers around the world than your user\u0027s mobile device, plus downloading and parsing HTML on the server side is going to be a lot quicker than a mobile device.\n2. Lower bandwidth: Facebook returns its results as JSON and therefore the bandwidth usage is much lower than downloading entire HTML pages and parsing them on a mobile device.\n\nYou can use the Facebook resolver simply by setting it to be the default app link resolver:\n\n```csharp\nAppLinks.DefaultResolver = new FacebookIndexAppLinkResolver (\"YOUR-FB-APP-ID\", \"YOUR-FB-APP-TOKEN\");\n```\n\nNOTE: To use the Facebook Index you must provide an **App ID** and **App Client Token**.  You can get these by signing up at the Facebook Developer\u0027s site, and creating an Application.  The App ID will be listed on your Facebook Application\u0027s Dashboard.  The Client Token comes from the Settings -\u003e Advanced page, under Security (Client Token).\n\n\n","Hash":"0f08f9e179e61e87e935656945712cda","TargetPlatforms":["ios","android"],"TrialHash":null}